/**
 * Glossary Translation Script
 * 
 * Translates all glossary terms from English into 6 target languages simultaneously.
 * Processes 2 terms per step to avoid rate limiting.
 * 
 * Usage: node scripts/translate_glossary.mjs
 */

import translate from 'google-translate-api-x';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Target languages
const TARGET_LANGUAGES = ['es', 'fr', 'de', 'zh-CN', 'ja', 'pt'];

// Terms to translate per batch
const TERMS_PER_BATCH = 2;

// Delay between batches (ms)
const BATCH_DELAY = 1500;

// Retry configuration
const MAX_RETRIES = 3;
const RETRY_DELAY = 2000;

/**
 * Extract glossary terms from the Glossary.tsx file
 */
function extractGlossaryTerms() {
    const glossaryPath = path.join(__dirname, '../src/features/game/Glossary.tsx');
    const content = fs.readFileSync(glossaryPath, 'utf-8');

    // Extract the glossaryTerms array
    const arrayMatch = content.match(/export const glossaryTerms: GlossaryTerm\[\] = \[([\s\S]*?)\];/);
    if (!arrayMatch) {
        throw new Error('Could not find glossaryTerms array in Glossary.tsx');
    }

    const arrayContent = arrayMatch[1];

    // Parse each term object
    const terms = [];
    const termRegex = /\{\s*id:\s*'([^']+)',\s*term:\s*'([^']+)',\s*definition:\s*'([^']+)',\s*category:\s*'([^']+)'\s*\}/g;

    let match;
    while ((match = termRegex.exec(arrayContent)) !== null) {
        terms.push({
            id: match[1],
            term: match[2],
            definition: match[3],
            category: match[4]
        });
    }

    // Also try double-quoted strings
    const termRegex2 = /\{\s*id:\s*["']([^"']+)["'],\s*term:\s*["']([^"']+)["'],\s*definition:\s*["'](.+?)["'],\s*category:\s*["']([^"']+)["']\s*\}/g;

    while ((match = termRegex2.exec(arrayContent)) !== null) {
        // Check if already added
        if (!terms.find(t => t.id === match[1])) {
            terms.push({
                id: match[1],
                term: match[2],
                definition: match[3].replace(/\\'/g, "'"),
                category: match[4]
            });
        }
    }

    console.log(`ğŸ“š Extracted ${terms.length} glossary terms`);
    return terms;
}

/**
 * Translate text to a specific language with retry logic
 */
async function translateText(text, targetLang) {
    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        try {
            const result = await translate(text, { to: targetLang, autoCorrect: true });
            return result.text;
        } catch (error) {
            if (attempt < MAX_RETRIES) {
                console.log(`  âš ï¸ Retry ${attempt}/${MAX_RETRIES} for ${targetLang}...`);
                await sleep(RETRY_DELAY * attempt);
            } else {
                console.error(`  âŒ Failed to translate to ${targetLang}: ${error.message}`);
                return text; // Return original on failure
            }
        }
    }
    return text;
}

/**
 * Translate a single term to all languages
 */
async function translateTermToAllLanguages(term) {
    const translations = {};

    // Translate term name and definition to all languages in parallel
    const translationPromises = TARGET_LANGUAGES.map(async (lang) => {
        const [translatedTerm, translatedDefinition] = await Promise.all([
            translateText(term.term, lang),
            translateText(term.definition, lang)
        ]);

        translations[lang] = {
            id: term.id,
            term: translatedTerm,
            definition: translatedDefinition,
            category: term.category // Keep category in English for consistency
        };
    });

    await Promise.all(translationPromises);
    return translations;
}

/**
 * Sleep for specified milliseconds
 */
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Generate TypeScript file content for translated glossary
 */
function generateTsContent(terms, lang) {
    const langNames = {
        'es': 'Spanish',
        'fr': 'French',
        'de': 'German',
        'zh-CN': 'Chinese (Simplified)',
        'ja': 'Japanese',
        'pt': 'Portuguese'
    };

    let content = `/**
 * Glossary Terms - ${langNames[lang]}
 * Auto-generated by translate_glossary.mjs
 * Generated: ${new Date().toISOString()}
 */

export const glossaryTerms_${lang.replace('-', '_')} = [\n`;

    terms.forEach((term, index) => {
        const escapedTerm = term.term.replace(/'/g, "\\'").replace(/"/g, '\\"');
        const escapedDef = term.definition.replace(/'/g, "\\'").replace(/"/g, '\\"');

        content += `    { id: '${term.id}', term: '${escapedTerm}', definition: '${escapedDef}', category: '${term.category}' }`;
        content += index < terms.length - 1 ? ',\n' : '\n';
    });

    content += '];\n';
    return content;
}

/**
 * Main translation function
 */
async function translateGlossary() {
    console.log('ğŸŒ Glossary Translation Script');
    console.log('================================');
    console.log(`ğŸ“ Target languages: ${TARGET_LANGUAGES.join(', ')}`);
    console.log(`ğŸ“¦ Terms per batch: ${TERMS_PER_BATCH}`);
    console.log('');

    // Extract terms from Glossary.tsx
    let terms;
    try {
        terms = extractGlossaryTerms();
    } catch (error) {
        console.error('âŒ Failed to extract glossary terms:', error.message);
        process.exit(1);
    }

    if (terms.length === 0) {
        console.error('âŒ No terms found to translate');
        process.exit(1);
    }

    // Initialize translation storage for each language
    const allTranslations = {};
    TARGET_LANGUAGES.forEach(lang => {
        allTranslations[lang] = [];
    });

    // Process terms in batches
    const totalBatches = Math.ceil(terms.length / TERMS_PER_BATCH);
    console.log(`ğŸ“Š Total terms: ${terms.length}`);
    console.log(`ğŸ“Š Total batches: ${totalBatches}`);
    console.log('');
    console.log('ğŸš€ Starting translation...');
    console.log('');

    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
        const startIndex = batchIndex * TERMS_PER_BATCH;
        const endIndex = Math.min(startIndex + TERMS_PER_BATCH, terms.length);
        const batchTerms = terms.slice(startIndex, endIndex);

        const progress = ((batchIndex + 1) / totalBatches * 100).toFixed(1);
        console.log(`ğŸ“¦ Batch ${batchIndex + 1}/${totalBatches} (${progress}%) - Terms ${startIndex + 1}-${endIndex}`);

        // Translate all terms in this batch to all languages simultaneously
        const batchPromises = batchTerms.map(async (term) => {
            console.log(`  ğŸ”„ Translating: "${term.term}"`);
            const translations = await translateTermToAllLanguages(term);
            return { term, translations };
        });

        const results = await Promise.all(batchPromises);

        // Store results
        results.forEach(({ translations }) => {
            TARGET_LANGUAGES.forEach(lang => {
                allTranslations[lang].push(translations[lang]);
            });
        });

        console.log(`  âœ… Batch complete`);

        // Delay between batches to avoid rate limiting
        if (batchIndex < totalBatches - 1) {
            await sleep(BATCH_DELAY);
        }
    }

    console.log('');
    console.log('ğŸ’¾ Saving translation files...');

    // Create output directory if it doesn't exist
    const outputDir = path.join(__dirname, '../src/features/game/data/locales/glossary');
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }

    // Save each language file
    for (const lang of TARGET_LANGUAGES) {
        const content = generateTsContent(allTranslations[lang], lang);
        const filename = `${lang.replace('-', '_')}.ts`;
        const filePath = path.join(outputDir, filename);

        fs.writeFileSync(filePath, content, 'utf-8');
        console.log(`  âœ… Saved: ${filename} (${allTranslations[lang].length} terms)`);
    }

    console.log('');
    console.log('ğŸ‰ Translation complete!');
    console.log('');
    console.log('ğŸ“ Output files:');
    TARGET_LANGUAGES.forEach(lang => {
        console.log(`   - src/features/game/data/locales/glossary/${lang.replace('-', '_')}.ts`);
    });
}

// Run the script
translateGlossary().catch(error => {
    console.error('âŒ Fatal error:', error);
    process.exit(1);
});
